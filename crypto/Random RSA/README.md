# Random RSA

The remote uses `random.getrandbits` to generate the numbers, and checks if the number is prime.

```python
‚ùØ nc chall.polygl0ts.ch 9022
Sadly, 37413308573804260570498978610974451525419325192454871278843769820116829539272279436918873404525645085492140731770987098491039488770756897066206603614819744371913925099363452417397741408890114774674192439653244663739158587920734154445144226138959981274337671072856815547739944074245913296817381756823769628493 was not prime
Sadly, 68459820455189257847148824012717907558795574468277604802814667809715942370578206507298083754834161018513233916977759395569324704603199346918028768885306351749194467358205257383803002272015626594838770231327047270283526358689992592810053006457797026431603561143901243834202945449111187387732769635330696197114 was not prime
Sadly, 170922558345666879859882160595455417309764278259722697410850620460668026955374233174926351455020020501226315603368097751737028853305716974952457216552628511159894211518722106462522072352474805449848671881355065520003149962799641760521703905555881381191844797108517075682137740923803180688600424688286766130700 was not prime
Sadly, 23802362262107404048090448985097866910111300772100315385025027441703217247462238465847079587629883563638722433238991678934592676828353413309159742281526386902445628352417168484026384021292507580686461509560509479270665230428425388987197972571886690679549605136736520592277438075005508320048128605863582758259 was not prime
Sadly, 117658728394848858685467812912997767859298234325233449823108081455310720611798685840378622993846740357390923240551305707718119551932603056781438794044216891127513143740040818788076452289924677293350742861004236198279263992477038790605941230549196983030744582542978411421778518563359386218472578534571589961156 was not prime
Sadly, 26424479249377357340099137812706377617615589057559436475052206023851501856393479929904876289688374321644655661755889572117496649909408930828419542475106750521869612714459416844152413229231275778091131649579251541895622899484908209588295164772755330913243480059349178128348433629226384718730014767966534806307 was not prime
{...}
Ciphertext: 1358540456210015477803058247951351359407679941025846527912909111622226002110017376735974736509925839874067142403568485837879475306447974122185039424773635648698988234830971603801717208527128250849331094556322952441353105111285205993495773974893482504859413385280315705920698816348190009066303142271743213373804771856300186412800080662354068789013805092383832625343979176674489385725156196636648546646711640139197565493990535627729847903515787415976306333063797190795768975552211575724120556164985031827722633915056330307092329661452334934770444626390236194646188872543951589272569141870620438740362174971888391960514
```

As `random.getrandbits` uses the mersienne twister to generate pseudo random numbers and we have a large set out outputs, we can sync our local state of the random module with the remote by feeding it into a mersienne twister predictor.

After having synced the predictor we get $p$ by generating the next 1024-bit value and use a modified version of the getPrime function to find $q$.

```python
from mt19937predictor import MT19937Predictor
from Crypto.Util.number import isPrime
from Crypto.Util.number import inverse

# Generate the next prime number
def getPrime(n_bits, verbose=False):
    while True:
        a = predictor.getrandbits(n_bits)
        if isPrime(a):
            return a
        elif verbose:
            print(f"Sadly, {a} was not prime")

# Read numbers from file
def read_numbers(file_path):
    numbers = []
    with open(file_path, 'r') as file:
        for line in file:
            number = int(line.strip())
            numbers.append(number)
    return numbers

# Main routine
if __name__ == "__main__":
    file_path = 'numbers.txt'

    # Given values
    e = 65537
    ciphertext = 1358540456210015477803058247951351359407679941025846527912909111622226002110017376735974736509925839874067142403568485837879475306447974122185039424773635648698988234830971603801717208527128250849331094556322952441353105111285205993495773974893482504859413385280315705920698816348190009066303142271743213373804771856300186412800080662354068789013805092383832625343979176674489385725156196636648546646711640139197565493990535627729847903515787415976306333063797190795768975552211575724120556164985031827722633915056330307092329661452334934770444626390236194646188872543951589272569141870620438740362174971888391960514

    # Read the numbers from the file
    outputs = read_numbers(file_path)

    # Initialize the predictor
    predictor = MT19937Predictor()

    # We can use the 1024-bit outputs from the file to sync the predictor state
    for output in outputs:
        predictor.setrandbits(output, 1024)

    # Once we have enough values, we can predict our prime
    p = predictor.getrandbits(1024)

    # We can use a modified getPrime function to find the next prime number with our predictor
    q = getPrime(1024)

    # Calculate the private exponent
    phi = (p - 1) * (q - 1)
    d = inverse(e, phi)

    # Decrypt the ciphertext
    m = pow(ciphertext, d, p * q)
    message = int.to_bytes(m, (m.bit_length() + 7) // 8, 'big')

    # Print the flag
    print(message)
```

Flag: **`EPFL{w0w_s0_much_r4nd000o0oo0om}`**